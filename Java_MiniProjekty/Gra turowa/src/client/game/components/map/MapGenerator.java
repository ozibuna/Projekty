package client.game.components.map;

import client.game.components.map.tile.*;
import client.game.components.unit.npc.Dragon;
import client.game.components.Castle;

import java.util.*;

import static java.lang.StringTemplate.STR;

public class MapGenerator {
    /**
     * The number of seeds used in the map generation process.
     * Seeds determine the randomness of the generated map.
     * A greater number of seeds will result in a more varied map.
     * Seed number should be a multiple of 3 so occurrences of Desert, Mountain and Forest are present
     * with similar sizes and probability.
     */
    private static final int NUMBER_OF_SEEDS = 39;
    /**
     * The number of villages in the map.
     */
    private static final int VILLAGE_NUMBER = 25;
    /**
     * The size of a cohesive biome.
     * <p>
     * This variable represents the size of a cohesive biome, which is a group
     * of tiles of the same terrain type that are adjacent to each other.
     * A cohesive biome is determined by the connectivity and proximity of its tiles.
     * <p>
     * This variable is used in the {@link MapGenerator} class to generate the map.
     * It helps in controlling the size of cohesive biomes in the generated map.
     * The value of this variable should be greater than 0.
     * <p>
     * The default value is {@code 20}.
     * <p>
     * Example usage:
     * <pre>{@code
     * int biomeSize = COHESIVE_BIOME_SIZE;
     * }</pre>
     */
    private static final int COHESIVE_BIOME_SIZE = 20;
    /**
     * The size of the map.
     */
    private int mapSize;
    /**
     *
     */
    private final Random random;
    /**
     * Represents the map as a 2D array of 'Tile' objects.
     */
    private Tile[][] map;
    /**
     * Private field that holds a list of Castle objects.
     */
    private final List<Castle> castles;
    /**
     *
     */
    private final List<Class<? extends Tile>> terrains;

    /**
     * The MapGenerator class is responsible for generating a world map with tiles, castles, and NPCs.
     * It provides methods for generating the map, placing castles, villages, and NPCs, and spawning a dragon.
     */
    public MapGenerator() {
        random = new Random();
        terrains = new ArrayList<>();
        castles = new ArrayList<>(4);
    }

    /**
     * Generates a map of size mapSize.
     *
     * @param mapSize the size of the map
     * @return a 2D array of Tiles representing the generated map
     */
    public Tile[][] generateMap(int mapSize, int playerNumber) {
        this.mapSize = mapSize;
        map = new Tile[mapSize][mapSize];
        generateCrossWaterPath();
        seedTerrains();
        expandTerrains();
        placeVillage(VILLAGE_NUMBER);
        placeCastles(playerNumber);
        fillNullSpaces();
        spawnDragon();
        return map;
    }
    /**
     * Retrieves a list of castles.
     *
     * @return a list of Castle objects representing the castles on the map
     */
    public List<Castle> castles() {
        return castles;
    }

    /**
     * Generates a cross-shaped path of water tiles on the map.
     * The path starts from the center of the map and extends towards the edges.
     * The path is randomly generated by slightly varying the Y-coordinate for each X-coordinate,
     * and then slightly varying the X-coordinate for each Y-coordinate.
     *
     * The generated water tiles are 5 tiles wide and cover a total of 11 tiles in length.
     *
     * The method does not return anything, it updates the map array directly.
     */
    private void generateCrossWaterPath() {
        int curY = mapSize / 2;
        for (int x = 0; x < mapSize; x++) {
            curY += random.nextInt(3) - 1;
            curY = Math.max(2, Math.min(curY, mapSize - 3));

            map[x][curY] = new Water(x, curY);
            map[x][curY - 1] = new Water(x, curY - 1);
            map[x][curY + 1] = new Water(x, curY + 1);
            map[x][curY - 2] = new Water(x, curY - 2);
            map[x][curY + 2] = new Water(x, curY + 2);
        }

        int curX = mapSize / 2;
        for (int y = 0; y < mapSize; y++) {
            curX += random.nextInt(3) - 1;
            curX = Math.max(2, Math.min(curX, mapSize - 3));

            map[curX][y] = new Water(curX, y);
            map[curX - 1][y] = new Water(curX - 1, y);
            map[curX + 1][y] = new Water(curX + 1, y);
            map[curX - 2][y] = new Water(curX - 2, y);
            map[curX + 2][y] = new Water(curX + 2, y);
        }
    }

    /**
     * Places villages on the map.
     *
     * @param quantity the number of villages to be placed
     */
    private void placeVillage(int quantity) {
        int villageX, villageY;
        while (quantity > 0) {
            do {
                villageX = random.nextInt(mapSize);
                villageY = random.nextInt(mapSize);
            } while (map[villageX][villageY] instanceof Water || map[villageX][villageY] instanceof Village);
            quantity--;
            map[villageX][villageY] = new Village(villageX, villageY);
        }
    }

    /**
     * Places castles on the map at specific positions.
     *
     * <p>The method calculates positions for each castle with random variation
     * and adds the castles to the map and the list of castles.</p>
     *
     * <p>The positions are calculated based on the following parameters:</p>
     * <ul>
     *    <li>baseDistance: Distance from the exact corner</li>
     *    <li>variationRange: Maximum variation from the base distance</li>
     * </ul>
     *
     * <p>The method first calculates positions for the top left and top right castles.
     * The x-coordinate is determined by adding a random value between 0 (inclusive) and the variation range (exclusive)
     * to the base distance.
     * The y-coordinate is determined in the same way.
     *
     * Next, positions for the bottom left and bottom right castles are calculated.
     * The x-coordinate for the bottom left castle is determined in the same way as for the top left castle,
     * while the y-coordinate is determined by subtracting a random value between 0 (inclusive) and the variation range (exclusive)
     * from the map size minus the base distance minus 1.
     *
     * Similarly, the x-coordinate for the bottom right castle is determined in the same way as for the top right castle,
     * while the y-coordinate is determined in the same way as for the bottom left castle.
     *
     * Finally, the castles are added to the map and the list of castles
     * at the calculated positions.</p>
     */
    private void placeCastles(int playerNumber) {
        // Distance from the exact corner
        int baseDistance = 5;
        // Maximum variation from the base distance
        int variationRange = 5;

        // Calculate positions for each castle with random variation
        if(playerNumber >= 1) {
            addCastles(new int[]{baseDistance + random.nextInt(variationRange), baseDistance + random.nextInt(variationRange)});
            if(playerNumber >= 2) {
                addCastles(new int[]{mapSize - baseDistance - random.nextInt(variationRange) - 1, baseDistance + random.nextInt(variationRange)});
                if(playerNumber >= 3) {
                    addCastles(new int[]{baseDistance + random.nextInt(variationRange), mapSize - baseDistance - random.nextInt(variationRange) - 1});
                    if (playerNumber >= 4) {
                        addCastles(new int[]{mapSize - baseDistance - random.nextInt(variationRange) - 1, mapSize - baseDistance - random.nextInt(variationRange) - 1});
                    }
                }
            }
        }
    }

    /**
     * This method is used to spawn a dragon on the map. The dragon is placed on a randomly selected mountain tile that is a certain distance away from all castles.
     * If the dragon cannot be placed after a certain number of retries, a message will be displayed indicating the failure.
     */
    private void spawnDragon() {
        int mountainX, mountainY;
        int maxRetries = 100;
        int retries = 0;
        boolean dragonPlaced = false;
        int minDistanceFromCastle = 20;

        while (!dragonPlaced && retries < maxRetries) {
            do {
                mountainX = random.nextInt(mapSize);
                mountainY = random.nextInt(mapSize);
            } while (!(map[mountainX][mountainY] instanceof Mountains)); // Ensure it's a mountain tile

            if (isDistantFromAllCastles(mountainX, mountainY, minDistanceFromCastle)) {
                map[mountainX][mountainY].setUnitOnTile(new Dragon(2));
                dragonPlaced = true;
            }
            retries++;
        }

        if (!dragonPlaced) {
            System.out.println("Failed to place the dragon after " + maxRetries + " attempts.");
        }
    }
    /**
     * Determines if a given point is distant enough from all castles.
     *
     * @param x           the x-coordinate of the point
     * @param y           the y-coordinate of the point
     * @param minDistance the minimum distance required from the castles
     * @return true if the point is distant from all the castles, false otherwise
     */
    private boolean isDistantFromAllCastles(int x, int y, int minDistance) {
        for (Castle castle : castles) {
            int[] coords = castle.getCoordinates();
            int distance = Math.abs(coords[0] - x) + Math.abs(coords[1] - y); // Manhattan distance
            if (distance < minDistance) {
                return false;
            }
        }
        return true;
    }

    /**
     * Adds castles to the map at the given positions.
     *
     * @param castle The position of the castle castle as an array of two integers: [x, y].
     */
    private void addCastles(int[] castle) {
        map[castle[1]][castle[0]] = new Castle(castle[0], castle[1]);
        castles.add((Castle) map[castle[1]][castle[0]]);
    }

    /**
     * Seeds the map with terrains by randomly placing seed points and creating terrains around them.
     * The seed points are placed at a minimum distance from each other to ensure variety in terrains.
     * It uses a maximum number of retries to place a seed if there are no available spaces.
     * If the minimum distance becomes 1 and no space is available, the loop breaks to avoid infinite loop.
     * If not all seeds could be placed, a warning message is printed.
     */
    private void seedTerrains() {
        int minDistance = 80; // Minimum distance between seed points
        int maxRetries = 50; // Maximum number of retries for placing a seed
        int placedSeeds = 0;

        while (placedSeeds < NUMBER_OF_SEEDS) {
            int x = 0, y = 0;
            boolean spaceAvailable = false;
            int retries = 0;

            while (!spaceAvailable && retries < maxRetries) {
                x = random.nextInt(mapSize);
                y = random.nextInt(mapSize);
                spaceAvailable = true;

                // Check surrounding area to ensure minimum distance between seeds
                for (int dx = -minDistance; dx <= minDistance; dx++) {
                    for (int dy = -minDistance; dy <= minDistance; dy++) {
                        int nx = x + dx;
                        int ny = y + dy;
                        // Check bounds and occupancy
                        if (nx >= 0 && nx < mapSize && ny >= 0 && ny < mapSize && map[nx][ny] != null) {
                            spaceAvailable = false;
                            break;
                        }
                    }
                    if (!spaceAvailable) {
                        break;
                    }
                }
                retries++;
            }

            if (spaceAvailable) {
                map[x][y] = createRandomTile(x, y);
                placedSeeds++;
            } else {
                // Reduce the minimum distance if too many retries happen without a placement
                if (minDistance > 1) {
                    minDistance--;
                } else {
                    // Break the loop if minDistance is 1 and no space is available to avoid infinite loop
                    break;
                }
            }
        }

        if (placedSeeds < NUMBER_OF_SEEDS) {
            System.out.println(STR."Warning: Only \{placedSeeds} out of \{NUMBER_OF_SEEDS} seeds could be placed.");
        }
    }

    /**
     * Fills the null spaces in the map with Plain tiles.
     * If a tile in the map is null, it will be replaced with a new Plain tile.
     * The Plain tile will have the x and y coordinates of the null tile.
     */
    private void fillNullSpaces() {
        for (int y = 0; y < mapSize; y++) {
            for (int x = 0; x < mapSize; x++) {
                if (map[x][y] == null) {
                    map[x][y] = new Plain(x, y);
                }
            }
        }
    }

    /**
     * Expands the terrains of the map by randomly increasing the size of terrain biomes.
     * Excludes water tiles from expansion.
     */
    private void expandTerrains() {
        for (int x = 0; x < mapSize; x++) {
            for (int y = 0; y < mapSize; y++) {
                if (map[x][y] != null && !(map[x][y] instanceof Water)) { // Excluding water tiles from expansion
                    if (map[x][y] instanceof Mountains) {

                    }
                    expandTerritory(x, y, map[x][y]);
                }
            }
        }
    }

    /**
     * Expands the territory around a given starting point with a specified prototype tile.
     *
     * @param startX     the x-coordinate of the starting point
     * @param startY     the y-coordinate of the starting point
     * @param prototype  the prototype tile used for expansion
     */
    private void expandTerritory(int startX, int startY, Tile prototype) {
        Queue<int[]> frontier = new LinkedList<>();
        frontier.add(new int[]{startX, startY});
        int expandedCount = 1;  // Start at 1 since the initial tile counts towards the biome

        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};

        while (!frontier.isEmpty() && expandedCount < MapGenerator.COHESIVE_BIOME_SIZE) {
            int[] current = frontier.poll();
            int curX = current[0];
            int curY = current[1];

            // Shuffle directions to ensure random expansion
            List<Integer> directions = Arrays.asList(0, 1, 2, 3);
            Collections.shuffle(directions);

            for (int dirIndex : directions) {
                int i = directions.get(dirIndex);
                int nx = curX + dx[i];
                int ny = curY + dy[i];

                if (nx >= 0 && ny >= 0 && nx < mapSize && ny < mapSize && map[nx][ny] == null) {
                    double expansionProbability = 0.5 * (1 - ((double) expandedCount / MapGenerator.COHESIVE_BIOME_SIZE)); // Reducing probability as it expands
                    if (random.nextDouble() < expansionProbability) {
                        map[nx][ny] = createNewTileInstance(prototype.getClass(), nx, ny);
                        frontier.add(new int[]{nx, ny});
                        expandedCount++;
                        if (expandedCount >= MapGenerator.COHESIVE_BIOME_SIZE) break; // Stop expanding if limit is reached
                    }
                }
            }
        }
    }

    /**
     * Creates a new instance of a Tile subclass with the specified coordinates.
     *
     * @param tileClass the class of the Tile subclass to create
     * @param x the x-coordinate of the Tile
     * @param y the y-coordinate of the Tile
     * @return a new instance of the specified Tile subclass with the given coordinates
     * @throws RuntimeException if the instantiation of the Tile fails
     */
    private Tile createNewTileInstance(Class<? extends Tile> tileClass, int x, int y) {
        try {
            return tileClass.getConstructor(int.class, int.class).newInstance(x, y);
        } catch (Exception e) {
            throw new RuntimeException("Tile instantiation failed", e);
        }
    }

    /**
     * Creates a random tile with the given coordinates.
     *
     * @param x The x-coordinate of the tile.
     * @param y The y-coordinate of the tile.
     * @return The created Tile object.
     */
    private Tile createRandomTile(int x, int y) {
        Class<? extends Tile> randomTerrain;
        if (terrains.isEmpty()) initTerrains();
        randomTerrain = terrains.getFirst();
        terrains.removeFirst();
        return createNewTileInstance(randomTerrain, x, y);
    }

    /**
     * Returns a string representation of the MapGenerator object.
     *
     * This method generates a string representation of the map by iterating through each tile
     * in the 'map' array and appending its string representation to a StringBuilder object.
     * The string representation of each tile is obtained using the Arrays.toString() method.
     * Each tile's string representation is concatenated with a line break character ('\n') to
     * separate the tiles in the resulting string.
     *
     * @return a string representation of the map.
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        for (Tile[] tiles : map) {
            builder.append(STR."\{Arrays.toString(tiles)}\n");
        }
        return builder.toString();
    }

    /**
     * Initializes the terrains list by adding instances of the Forest, Mountains, and Desert classes.
     * These classes represent the different types of terrains that can be generated on the map.
     */
    private void initTerrains() {
        terrains.add(Forest.class);
        terrains.add(Mountains.class);
        terrains.add(Desert.class);
    }
}
